文字列型　

<?php
echo "文字列";
echo "文字列２";
?>

整数型
ダブルクォーテーションで囲まない

<?php
echo 100;
?>

浮動小数点型
PHPでも浮動小数点型は誤差が生じる
<?php
echo 0.1;
?>

論理型
<?php
echo TRUE;
echo FALSE;
?>


例１　整数型のみを使った計算
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>PHP四則演算計算>
</head>

<body>
    <p>
        <?php
        //四則演算（整数型のみ）
        echo 45 + 18;
        echo "<br>";
        echo 30 - 12;
        echo "<br>";
        echo 15 * 6;
        echo "<br>";
        echo "30 / 3";
        echo "<br>";
        echo 45 % 8;
        ?>
    </p>

    <p>
        <!-- 浮動小数点を含む計算 -->
        <?php
        echo 4.5 + 1.8;
        echo "<br>";
        echo 3 - 1.2;
        echo "<br>";
        echo 1.5 * 0.6;
        echo "<br>";
        echo 3 / 0.3;
        echo "<br>";
        //誤差が出る計算（結果が0.1にならない）
        echo 100 - 99.9;
        ?>
    </p>
</body>

</html>

浮動小数点型では剰余計算は行わないようにする
剰余計算とは余りを求める計算
理由は正しい結果が出ないから、小数点以下が切り捨てられ、整数型に変換されてから剰余演算が
行われる、よって例えば以下のような計算では小数点以下が切り捨てられて0になり
エラーが発生する
<?php
echo 45 % 0.8;
?>

文字列を連結する

JavaScriptでは足し算と同じように+を使って文字列を連結させるが
PHPでは「. ドット」を使う
.は結合演算子を使う

<p>
    <?php
    //文字列の連結
    echo "45" . "18";
    echo "<br>";
    echo "文字列を" . "連結";
    ?>
</p>

変数

変数は文字列型やデータを入れる箱のようなもの、変数の中身はいつでも入れ替える事が出来る

PHPで変数を使うには以下のようにする
$変数名 = 値;を記述するだけ

<?php
$user_name = "侍太郎";
?>

PHPでは事前に変数を宣言する必要はなく、値を代入した時点でその変数が使えるようになる

おさらい
・宣言「こんな名前の変数を使いますよ」と宣言すること
・代入　宣言した変数に実際の値（データ）を入れること

PHPでの悪い例
<?php
$user_name;
$user_name = "侍太郎";
?>

変数の使い方例

<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>変数の使い方</title>
</head>

<body>
    <p>
        <?php
        //変数を代入
        $user_name = "侍太郎";

        //変数の中身を出力
        echo $user_name;
        ?>
    </p>
</body>

</html>


変数の中身を入れ替える

<body>
    <p>
        <?php
        //変数を代入
        $user_name = "侍太郎";

        //変数の中身を出力
        echo $user_name;

        echo "<br>";

        //変数に値を再代入する
        $user_name = "侍花子";

        //変数を中身を出力
        echo $user_name;
        ?>
    </p>

    変数を使って、数値の計算や文字列を連結させる

    <?php
    //変数と数値の計算
    $number = 3;
    echo $number - 1.2;

    //変数と文字列の連結
    $my_name = "侍一郎";
    echo "私の名前は" . $my_name . "です";
    ?>

    文字列の中で変数の中身を表示する方法
    以下のように文字列をダブルクォーテーションで囲み、変数を｛｝波括弧で囲う

    <?php
    //文字列の中で変数の中身を表示させる
    ?my_name = "侍一郎";
    echo "私の名前は{$my_name}です。";
    ?>

    変数の中身を表示することを変数展開という
    なお文字列をシングルクォーテーションで囲むと変数名がそのまま表示される


    変数名の付け方のルール（命名規則）

    名前の付け方のルールのことを命名規則という

    PHPでは３つの命名規則を覚えておく
    1 先頭に$を付ける
    2 変数名はスネークケースで記述
    3　変数の中身が分かるような名前にする

    スネークケースとは単語と単語の間をアンダースコアで区切る記法
     例 $user_name $user_namber



配列

簡単なおさらい
データを変数で１つずつバラバラに管理するよりも１つのまとまったデータとして管理した方が楽
ここで配列を使う

PHPでの配列の作り方

$変数名　= ["値１","値２","値３"];

具体的な例

<?php
$user_names = ["文字列１", "文字列２", "文字列３"];
$user_ages = [36, 33, 39,];
?>

配列に入っているそれぞれの値の事を要素という



要素を取り出す方法
配列にした時点で番号が０、１、２と順番に振られている
この番号の事をインデックスという

このインデックスを使って配列名と取り出したいインデックスを記述すると取り出せる

例
<?php
$user_names = ["文字列１", "文字列２", "文字列３"];

//二番目の要素を取り出す
echo $user_names[1];
?>


要素を更新、追加する方法
PHPでも配列の要素を更新、追加することができる
この際も以下のようにインデックスを使う

例
$user_names = ["文字列１", "文字列２", "文字列３"];

//二番目の要素を更新
$user_names[1] = "文字列new";

//４番目に要素を追加
$uder_names[3] = "文字列add";
?>


[]の中を空欄にしておくと、自動的に配列の末尾に要素が追加される
配列の末尾に要素を追加するだけであれば、こちらのほうが簡単で指定ミスも怒らない

<?php
$user_names = ["文字列1", "文字列２", "文字列３"];

//要素を追加
$user_names[] = "文字列4";
?>

連想配列
例えば、「名前」「年齢」「性別」「住所」「電話番号」など、異なる種類のデータをまとめて管理したい場合
以下のように配列にすることも可能ですが、何番目に何のデータが入っているかがわかりにくいため、管理が難しくなってしまいます
ここで連想配列が役に立つ
<?php
// 配列
$personal_data = ['侍太郎', 36, '男性', '東京都', '020-0304-0506', '侍花子', 33, '女性', '京都府', '999-9999-9999'];
?>

連想配列を使えば以下のようにデータ名をつけられるので、異なる種類のデータも格段に管理しやすくなります

例
<>php
$personal_data1 = ["name" => "太郎", "age" => 36, "gender" => "男性"];
?>

連想配列とは
配列におけるインデックスの代わりにキーと言うラベルをつけて管理するデータのまとまりのこと

キー＝値が何を表すのかわかりやすく名前をつけたもの

配列：各要素に０から順番に番号「インデックス」を振って管理する
連想配列：インデックスの代わりにキーと呼ばれるラベルをつけて管理する

連想配列の作り方、値を取り出す方法
<?php
//値を作る
$personal_data = ["name" => "太郎", "age" => 36, "gender" => "男性"];
//値を取り出す
echo $personal_data["gender"];
?>

値を更新、追加

同じように更新したり追加したりできる、キーを使う

<?php
$personal_data = ["name" => "太郎", "age" => 36, "gender" => "男性"];

//ageというキーの値を更新する
$personal_data["age"] = 37;

//新しく要素（キーと値）を追加する
$personal_data["address"] = "東京都";
?>


条件分岐、IF文

おさらい条件分岐とは
ある条件に当てはまるときだけこの処理を実行したいという時に使う

PHPでのifの書き方

if (条件式) {
    条件が成り立つ時の処理
}

具体的な例
<?php
$num = 50;

//変数$numが１０より大きいなら「変数$numは１０より大きいです」と出力
if ($num > 10){
    echo "変数$numは１０より大きい";
}

おさらい戻り値、返り値とは
比較演算子を使って２つの値を比較する事でTRUE、FALSEどっちかの値がかえってくる
その返ってきた値がTRUEであれば処理をするのがif文。
この返ってきた値のことを返り値、戻り値という

戻り値の出力
<?php
//算術演算子を使った場合の戻り値を出力する
echo 45 + 18;

echo "<br>"

//比較演算を使った場合の戻り値を出力
var_dump(45 > 18);
?>


おさらい比較演算子

==  ２つの値が等しい場合はTRUEを返す（等価演算子）
=== ２つの値とデータ型が等しい場合はTRUEを返す（厳密等価演算子）
!=  ２つの値が等しくない場合はTRUEを返す
!== ２つの値とデータ型が等しくない場合はTRUEを返す
>   左辺の値が右辺の値よりも大きい場合はTRUEを返す
>=  左辺の値が右辺の値以上の場合はTRUEを返す
<   左辺の値が右辺の値よりも小さい場合はTRUEを返す
<=  左辺の値が右辺の値以下の場合はTRUEを返す

簡単なif文の記述例

<?php
//0~4までのランダムな整数を代入
$num = mt_rand(0,4);

//出力
echo $num;
echo "<br>";

//変数$numの値が４であれば、「大当たり」と表示
if ($num === 4) {
    echo "大当たり";
}
?>


ifとelseを記述するパターン

if(条件式) {
    条件が成り立つときの処理
} else {
    条件が成り立たない時の処理
}

具体的な例
<?php
$num = mt_rand(0,4);

//出力
echo $num;
echo "<br>";

//変数$numの値が４であれば、「大当たり」と表示
//それ以外は「はずれ」と表示
if ($num === 4) {
    echo "大当たり";
} else {
    echo "はずれ";
}
?>

　if、elseif。elseを記述するパターン

変数$numに0～4までのランダムな整数を代入する
変数$numの値が4であれば、「大当たりです」という文字列を出力する
変数$numの値が3であれば、「当たりです」という文字列を出力する
それ以外のときは、「はずれです」という文字列を出力する

if (条件式A) {
  条件Aが成り立つときの処理
} elseif (条件式B) {
  条件Bが成り立つときの処理  
} else {
  どの条件も成り立たないときの処理
}

具体的な例

<?php
        // 変数$numに0～4までのランダムな整数を代入する
        $num = mt_rand(0, 4);

        // 変数$numの値を出力する（確認用）
        echo $num;

        // 改行する
        echo '<br>';

        // 変数$numの値が4であれば、「大当たりです」という文字列を出力する
         // 変数$numの値が3であれば、「当たりです」という文字列を出力する
        // それ以外のときは、「はずれです」という文字列を出力する
        if ($num === 4) {
            echo '大当たりです';
         } elseif ($num === 3) {
             echo '当たりです';
        } else {
            echo 'はずれです';
        }
        ?>

        「かつ」「または」で複数の条件式を組み合わせる方法

        男性かつ20歳以上のとき」「月曜日または水曜日のとき」など
        複数の条件式を組み合わせたい場面もあります。そのようなときは、以下のように&&（かつ）や||（または）を記述します。


<?php
// &&（かつ）を記述して、すべての条件が成り立つ場合にのみ処理を行う（変数$numの値が11～29）
if ($num > 10 && $num < 30) {
    echo '変数$numは10より大きく、30より小さいです';
}

// ||（または）を記述して、1つでも条件が成り立てば処理を行う（変数$numの値が10または30）
if ($num === 10 || $num === 30) {
    echo '変数$numは10または30です';
}
?>

この&&（かつ）や||（または）のことを論理演算子といいます。
&&はand、||はorに書き換えても同じように動作します



繰り返し処理のfor文

おさらい繰り返し処理とは
例えば1～10までの整数を順番に出力したいとき、
同じようなコードを何度も書くのは手間がかかる
そこで使うのが繰り返し処理
繰り返し処理とは、「決まった回数」または「条件を満たしている間」同じ処理を繰り返し行うこと
<?php
for ($i = 1; $i <= 10; $i += 1) {
    echo $i;
}
?>


PHPの代表的な繰り返し処理はfor文、while文、foreach文の3つ

それぞれの使い分け方
for文	    繰り返す回数があらかじめわかっている場合	        1～10までの数字を順番に表示する
while文	    繰り返す回数があらかじめわからない場合	            サイコロで6の目が出るまで繰り返す
foreach文	配列や連想配列に対して繰り返し処理を行いたい場合	配列の中に入っている都道府県の名前を順番に取り出し、フォームのセレクトボックスに表示する

 for文の書き方
 for (カウンタ変数の初期値; 条件式; カウンタ変数の増減値) {
    カウンタ変数が決まった値になるまで繰り返す処理
}

カウンタ変数とは、「繰り返し処理の回数を数えるために使われる変数」のこと

for文の使用例

<?php
for ($i = 1; $i <= 10; $i += 1) {
    echo $i;
}
?>

丸括弧()内のコードを分解
$i = 1：カウンタ変数の初期値（カウンタ変数$iに初期値を代入する）
$i <= 10：条件式（カウンタ変数$iの値が10以下のときにTRUEを返す）
$i += 1：カウンタ変数の増減値（処理を繰り返すごとに、カウンタ変数$iに1を加算する）

上記のコードはカウンタ変数$iが1からスタートし、処理を繰り返すごとに1ずつ加算されていきます。そして、カウンタ変数$iが10より大きくなる（条件式$i <= 10がFALSEになる）と、繰り返し処理が終了します。

代入演算子　カウンタ変数$iに1を加算するときに記述した+=は、代入演算子といいます

=	変数に右項の値を代入する（代入）。
+=	変数の値に右項の値を足して代入する（加算代入）。
-=	変数の値から右項の値を引いて代入する（減算代入）。
*=	変数の値に右項の値を掛けて代入する（乗算代入）。
/=	変数の値を右項の値で割って代入する（除算代入）。
%=	変数の値を右項の値で割った余りを代入する（剰余代入）。

インクリメント演算子とデクリメント演算子

i += 1やi -= 1のように単純に1増やしたり1減らしたりしたい場合、以下のように書き換えることもできます
$i += 1→ $i++
$i -= 1→ $i--
この++のことをインクリメント演算子、--のことをデクリメント演算子といいます

インクリメント＝増加
デクリメント＝減少

for文記述例
 <?php
         // 1～10までの整数を順番に出力する
         for ($i = 1; $i <= 10; $i++) {
             echo $i . '<br>';
         }
         ?>

繰り返し処理を行うときに必ず注意しなければならないのが、無限ループ
条件式がTRUEを返し続けるとき（FALSEを返す可能性がないとき）に発生します。

無限ループ例
<?php
// 条件式が常にTRUEを返すので、無限ループになる
for ($i = 1; $i <= 10; $i--) {
    echo $i . '<br>';
}
?>

break文

繰り返し処理の途中で強制終了し、ループから抜け出すことができます。以下のように、break文は一般的に条件分岐のif文と組み合わせて使います

<?php
for ($i = 1; $i <= 10; $i++) {
    echo $i;

    // カウンタ変数$iの値が5であれば、break文で繰り返し処理を強制終了する
    if ($i === 5) {
        break;
    }
}
?>

記述例

 <?php
         for ($i = 1; $i <= 10; $i++) {
             // 変数$numに1～20までのランダムな整数を代入する
             $num = mt_rand(1, 20);
 
             echo "{$i}回目の結果は{$num}です。<br>";
 
             // 変数$numの値が20であれば、break文で繰り返し処理を強制終了する
             if ($num === 20) {
                 echo '20が出たので繰り返し処理を強制終了します。';
                 break;
             }
         }
         ?>

変数$numの値が20になった場合は、10回に満たなくてもbreak文によって繰り返し処理が強制終了されます。
20が出なかった場合は、以下のように通常どおり10回繰り返し処理が実行されます。


continue文

continue文は、繰り返し処理の途中で中断し、次のループに進む命令です。
continue文もbreak文と同じように、一般的に条件分岐のif文と組み合わせて使います。

例えば1～10までの整数のうち、偶数のみを出力したいときは、continue文を使って以下のようなコードを書くことで実現できます。
<?php
for ($i = 1; $i <= 10; $i++) {
    // カウンタ変数$iの値が奇数（2で割った余りが1）であれば、値を出力せずにcontinue文で次のループに進む
    if ($i % 2 === 1) {
        continue;
    }

    echo $i;
}
?>。

カウンタ変数$iの値が奇数の場合は、continue文によってそれ以降の処理（echo $i . '<br>';）がスキップされ、結果的に偶数のみが出力されます。


while文
「条件を満たしている間」同じ処理を繰り返し行うことができる
繰り返す回数があらかじめわからない場合	例、サイコロで6の目が出るまで繰り返す

while文の書き方
while文を使えば、「条件を満たしている間」同じ処理を繰り返し行うことができます。
while文では、if文やfor文と同じように条件式を使います。

while (条件式) {
    条件を満たしている間、繰り返す処理
}

while文の使用例を見てみましょう。
以下の$num !== 0の部分が条件式で、
変数$numの値が0以外のときにTRUEを返します。つまり以下の例では、
変数$numの値が0以外である間、同じ処理が繰り返し行われます。

<?php
// 変数$numに0～4までのランダムな整数を代入する
$num = mt_rand(0, 4);

// 変数$numの値が0以外である間、変数$numの値を出力し続ける
while ($num !== 0) {
    $num = mt_rand(0, 4);
    echo $num;
}
?>

具体的な例
変数$numの値が0以外である間、変数$numの値を出力し続ける
プログラムを作成

 <?php
         // 変数$numに0～4までのランダムな整数を代入する
         $num = mt_rand(0, 4);
 
         // 変数$numの最初の値を出力する（確認用）
         echo "最初の値は{$num}です。<br>";
 
         // 変数$numの値が0以外である間、変数$numの値を出力し続ける
         while ($num !== 0) {
             // 変数$numに0～4までのランダムな整数を代入する
             $num = mt_rand(0, 4);
 
             // 次の条件式で比較される、変数$numの現在の値を出力する
             echo "現在の値は{$num}です。<br>";
         }
         ?>

         while文を使えば条件を満たしている間、同じ処理を繰り返し行うことができます。

         
         無限ループ
while文もfor文と同様、無限ループが発生しないように
十分注意する必要があります。

無限ループ例
最初に変数$numに5を代入したきりそのままなので、
変数$numの値は常に5です。よって、条件式$num === 5は常にTRUEを返し
無限ループが発生してしまう

<?php
// 変数$numに5を代入する
$num = 5;

// 条件式が常にTRUEを返すので、無限ループになる
while ($num === 5) {
    echo $num;
}
?>

 break文

 while文でもbreak文を記述することで繰り返し処理の途中で強制終了し、ループから抜け出すことができます。
 一般的に条件分岐のif文と組み合わせて使う点も一緒です。
 
 具体的な例
 「変数$numの値が0以外である間、変数$numの値を出力し続けるプログラム」
 に対し、「最大で5回まで」という制限を加えてみます。
以下のように変数$numの値が0以外であっても、5回目でbreak文によって繰り返し処理が強制終了されます。
 <?php
        // 変数$numに0～4までのランダムな整数を代入する
        $num = mt_rand(0, 4);

         // カウンタ変数を用意する
         $i = 1;

        // 変数$numの最初の値を出力する（確認用）
        echo "最初の値は{$num}です。<br>";

        // 変数$numの値が0以外である間、変数$numの値を出力し続ける
        while ($num !== 0) {
            // 変数$numに0～4までのランダムな整数を代入する
            $num = mt_rand(0, 4);

            // 次の条件式で比較される、変数$numの現在の値を出力する
            echo "現在の値は{$num}です。<br>";

             // カウンタ変数$iの値が5であれば、break文で繰り返し処理を強制終了する
             if ($i === 5) {
                 echo '5回目なので繰り返し処理を強制終了します。';
                 break;
             }
 
             // カウンタ変数の値を1増やす
             $i++;
        }
        ?>

continue文
while文でもcontinue文を記述することで繰り返し処理の途中で中断し、次のループに進むことができます
一般的に条件分岐のif文と組み合わせて使う点も一緒です。

具体的な例

変数$numに1～10までのランダムな整数を代入する
変数$numの値を変数$sumに加算する（sum＝合計）
変数$numの値が偶数のときは、上記の処理をスキップする（結果的に奇数のみが加算される）
変数$sumの値が20以上になったら繰り返し処理を終了する


変数$numの値が偶数のときは、continue文によってそれ以降の処理
（$sum += $num;～）がスキップされ、結果的に奇数のみが加算されます。
そして、変数$sumの値が20以上になった時点で繰り返し処理が終了します。
<?php
         // 合計用の変数を用意する
         $sum = 0;
 
         // 変数$sumの値が20以上になるまで繰り返し処理を行う
         while ($sum < 20) {
             // 変数$numに1～10までのランダムな整数を代入する
             $num = mt_rand(1, 10);
            
             echo "{$num}が出ました。<br>";
 
             // 変数$numの値が偶数（2で割った余りが0）であれば、加算せずにcontinue文で次のループに進む
             if ($num % 2 === 0) {
                 echo '偶数なので加算しません。<br>';
                 continue;
             }
 
             // 変数$sumに変数$numの値を加算する
             $sum += $num;
 
             echo "現在の合計は{$sum}です。<br>";
         }
         ?>

foreach文
配列や連想配列に対して繰り返し処理を行うことができる


foreach文	配列や連想配列に対して繰り返し処理を行いたい場合	配列の中に入っている都道府県の名前を順番に取り出し、フォームのセレクトボックスに表示する

foreach文の書き方（配列の場合）

foreach文を使えば、配列や連想配列に対して繰り返し処理を行うことができます
foreach文は配列や連想配列の各要素を順番に取り出すので、「繰り返し処理の回数＝配列や連想配列の要素数」となります。

具体的な例
<?php
$user_names = ['侍太郎', '侍一郎', '侍二郎', '侍三郎', '侍四郎'];

//  配列$user_namesの要素を1つずつ順番に出力する
foreach ($user_names as $user_name) {
   echo $user_name;
}
?>

foreach文の丸括弧()内に記述された$user_names as $user_nameに注目してください。それぞれの意味は以下のとおりです。

$user_names：要素を取り出す配列名
$user_name：取り出した要素を代入する変数名

取り出した要素を代入する変数名は何でもよいのですが、一般的には配列名の単数形にすることが多いです。なお、この変数には配列から取り出した要素が順番に代入されます。

上記のコードを例にすると、以下のようなイメージです。

1周目：$user_name← '侍太郎'
2周目：$user_name← '侍一郎'
3周目：$user_name← '侍二郎'
4周目：$user_name← '侍三郎'
5周目：$user_name← '侍四郎'

繰り返し処理の中でこの変数を使えば、配列の各要素に対してさまざまな処理ができるということです。

foreach文具体的な例

 <?php
         $user_names = ['侍太郎', '侍一郎', '侍二郎', '侍三郎', '侍四郎'];
 
         //  配列$user_namesの要素を1つずつ順番に出力する
         foreach ($user_names as $user_name) {
             echo $user_name . '<br>';
         }
         ?>

 foreach文の書き方（連想配列の場合）


連想配列のキーと値を順番に出力したいときは、foreach文を使って以下のように書くことができます。

<?php
$personal_data = ['name' => '侍太郎', 'age' => 36, 'gender' => '男性'];

// 連想配列$personal_dataのキーと値を1つずつ順番に出力する
foreach ($personal_data as $key => $value) {
    echo "{$key}は{$value}です。";
}
?>
foreach文の丸括弧()内に記述された$personal_data as $key => $valueに注目してください。それぞれの意味は以下のとおりです。
$personal_data：要素を取り出す連想配列名
$key：取り出したキーを代入する変数名
$value：取り出した値を代入する変数名
取り出したキーや値を代入する変数名は何でもよいのですが、一般的にはそのまま$key（キー）と$value（値）にすることが多いです。なお、これらの変数には連想配列から取り出したキーと値が順番に代入されます。
上記のコードを例にすると、以下のようなイメージです。
1周目：$key← 'name'、$value← '侍太郎'
2周目：$key← 'age'、$value← 36
3周目：$key← 'gender'、$value← '男性'

繰り返し処理の中でこれらの変数を使えば、連想配列の各キー、各値に対してさまざまな処理ができるということです。
キーを取り出さずに値だけを取り出したいときは、以下のように$keyを省略することもできます。

<?php
$personal_data = ['name' => '侍太郎', 'age' => 36, 'gender' => '男性'];

// 連想配列$personal_dataの値を1つずつ順番に出力する
foreach ($personal_data as $value) {
    echo $value;
}
?>

連想配列を使ったforeach文の例

 <p>
         <?php
         $personal_data = ['name' => '侍太郎', 'age' => 36, 'gender' => '男性'];
 
         // 連想配列$personal_dataのキーと値を1つずつ順番に出力する
         foreach ($personal_data as $key => $value) {
             echo "{$key}は{$value}です。<br>";
         }
 
         // 連想配列$personal_dataの値を1つずつ順番に出力する
         foreach ($personal_data as $value) {
             echo $value . '<br>';
         }
         ?>


         補足：配列のインデックスを取り出すこともできる

         配列においても、foreach (配列名 as $index => $value) { ～ }のように記述することで、値だけでなくインデックスを取り出すことができます
          <?php
        $user_names = ['侍太郎', '侍一郎', '侍二郎', '侍三郎', '侍四郎'];

        //  配列$user_namesの要素を1つずつ順番に出力する
        foreach ($user_names as $user_name) {
            echo $user_name . '<br>';
        }

         //  配列$user_namesのインデックスと値を1つずつ順番に出力する
         foreach ($user_names as $index => $value) {
             echo "{$index}：{$value}<br>";
         }
        ?>

        セレクトボックスの選択肢をforeach文で作る
         フォームのセレクトボックスを題材にして、選択肢をPHPのforeach文で作ってみます。

         <p>出身地を選択してください。</p>
     <form>
         <select>
             <?php
             $birthplaces = [
                 '北海道地方',
                 '東北地方',
                 '関東地方',
                 '中部地方',
                 '近畿地方',
                 '中国・四国地方',
                 '九州地方'
             ];
 
             foreach ($birthplaces as $birthplace) {
                 echo "<option>{$birthplace}</option>";
             }
             ?>
         </select>
     </form>

     break文
     foreach文でもbreak文を記述することで繰り返し処理の途中で強制終了し、ループから抜け出すことができます。一般的に条件分岐のif文と組み合わせて使う点も一緒です。

     break文を使って以下のようなプログラムを作成してみます。

配列&user_namesに'侍二郎'という文字列が含まれているかどうか1つずつチェックする
'侍二郎'という文字列が見つかった時点で繰り返し処理を終了する

<?php
         $user_names = ['侍太郎', '侍一郎', '侍二郎', '侍三郎', '侍四郎'];
 
         // 検索したいユーザー名を代入する変数
         $target = '侍二郎';
 
         foreach ($user_names as $user_name) {
             echo $user_name . '<br>';
 
             // 変数$user_nameと変数$targetの値が一致すれば、break文で繰り返し処理を強制終了する
             if ($user_name === $target) {
                 echo "{$target}さんが見つかったので、繰り返し処理を強制終了します。";
                 break;
             }
         }
         ?>

         continue文
         foreach文でもcontinue文を記述することで繰り返し処理の途中で中断し、次のループに進むことができます。一般的に条件分岐のif文と組み合わせて使う点も一緒です。

         continue文を使って以下のようなプログラムを作成してみます。

    連想配列$scoreのキーに科目名、値に点数を入れる（5科目分）
    科目名と点数を順番に出力する
    点数が70点未満のときは、上記の処理をスキップする（結果的に70点以上の科目名と点数のみが出力される）

         <?php
         $score = [
             '国語' => 80,
             '数学' => 55,
             '理科' => 70,
             '社会' => 85,
             '英語' => 60
         ];
 
         echo '合格した科目は以下のとおりです。<br>';
 
         foreach ($score as $key => $value) {
             // 変数$valueの値（点数）が70より小さければ、キー（科目名）と値（点数）を出力せずにcontinue文で次のループに進む
             if ($value < 70) {
                 continue;
             }
 
             echo "{$key}：{$value}点<br>";
         }
         ?>

     関数

    例えば以下のように、朝のあいさつを出力する一連の処理があるとします
    （Webサービスのログイン時にあいさつが表示される場面をイメージしましょう）。
    このような一連の処理を何度も実行したくなる場面が必ずやってきます。
    しかし、その度に毎回同じ処理を記述するのは大変ですし、コードが無駄に長くなってしまいます。
    
    <?php
    echo 'おはようございます！';
    echo '昨日はよく眠れましたか？';
    echo '今日も一日頑張りましょう！';  
    ?>


   そこで大活躍するのが関数です
   関数を使えば以下のように、一度関数を作るだけで何度でも再利用できるようになります

    <?php   
    // 朝のあいさつを出力する関数を作成する
    function say_good_morning() {
     echo 'おはようございます！';
     echo '昨日はよく眠れましたか？';
     echo '今日も一日頑張りましょう！';
    }

    // 関数を呼び出す（1回目）
    say_good_morning();

    // 関数を呼び出す（2回目）
    say_good_morning();
    ?>
    関数とは、一連の処理をひとまとめにして、何度でも再利用できるようにする仕組みのことです。
    
    関数のメリットをまとめると以下のようになります。

    複雑なコードを1つにまとめられる
    同じ処理を行うときに何度でも再利用できる
    プログラミングの生産性を高め、素早い開発ができるようになる

    関数の作り方
    function 関数名() {
    一連の処理
    }

    具体的な例
    <?php
    function say_good_morning() {
        echo 'おはようございます！';
        echo '昨日はよく眠れましたか？';
        echo '今日も一日頑張りましょう！';
    }
    ?>

    関数名のつけ方
    関数名は変数と同じように、内容がわかる名前にするべきです。
    基本的に、プログラミング言語で関数名をつけるときは、「add_product（商品を追加する）」のように
    「動詞＋目的語」の形をとることが多いです。
    
    関数の呼び出し方

    関数を呼び出す（実行する）方法は簡単で、関数名を記述するだけです。
     <?php
         // 朝のあいさつを出力する関数を定義する
         function say_good_morning() {
             echo 'おはようございます！<br>';
             echo '昨日はよく眠れましたか？<br>';
             echo '今日も一日頑張りましょう！<br>';
         }
 
         // 夜のあいさつを出力する関数を定義する
         function say_good_evening() {
             echo 'こんばんは！<br>';
             echo '今日も一日お疲れさまでした。<br>';
         }
 
         // 朝のあいさつを出力する関数を呼び出す
         say_good_morning();
 
         // 夜のあいさつを出力する関数を呼び出す
         say_good_evening();
         ?>

         なお、「関数は定義しただけでは実行されない」という点に注意してください。関数は呼び出して初めて実行されます。
         
         
         関数の引数・戻り値
         引数（ひきすう）とは簡単にいえば、関数に与えるデータのことです。
         上記で作成した朝のあいさつを出力する関数であれば、決まった処理を行うだけなので引数は必要ありません。
         一方で、決まっていない値を使って処理を行いたいときには引数が必要です。

         例えば、購入金額に500円の送料を加算する関数を作りたいとします。
         この「購入金額」は決まっていない値です。関数で処理を行うために
         「購入金額」というデータが必要になります。そこで使うのが引数です。
         引数として購入金額を関数に与えることで、関数はその購入金額を使って計算を行えるようになります。
         
         引数の使い方
         function 関数名(引数名) {
         引数を使った一連の処理
        }
        <?php
        function calculate_total($price) {
            // 与えられた引数$priceに送料を加算し、変数$totalに代入する
            $total = $price + 500;

            // 変数$totalの値を出力する
            echo $total . '円';
        }
        ?>

        <?php
         // 与えられた引数$priceに送料を加算し、その値を出力する関数を定義する
         function calculate_total($price) {            
             $total = $price + 500;
             
             echo $total . '円<br>';
         }
 
         // 関数を呼び出し、引数として購入金額を渡す
         calculate_total(1200);
         ?>

         複数の引数を受け取る関数
         
         2つ以上の引数を渡すこともできます。
         例えば北海道や沖縄など、地域によって送料が異なるケースです。
         複数の引数を渡す場合は、以下のようにカンマ区切りで引数を記述します。
         関数を呼び出すときも同様に、同じ数の引数を渡します。
         <?php
        function add_two_arguments($price, $shipping_fee) {
         // 与えられた引数$priceと引数$shipping_feeを加算し、変数$totalに代入する
         $total = $price + $shipping_fee;

        // 変数$totalの値を出力する
        echo $total . '円';
    }
    ?>

    具体的な例
    <?php
        // 与えられた引数$priceに送料を加算し、その値を出力する関数を定義する
        function calculate_total($price) {
            $total = $price + 500;

            echo $total . '円<br>';
        }

        // 関数を呼び出し、引数として購入金額を渡す
        calculate_total(1200);

         // 与えられた引数$priceと引数$shipping_feeを加算し、その値を出力する関数を定義する
         function add_two_arguments($price, $shipping_fee) {
             $total = $price + $shipping_fee;
 
             echo $total . '円<br>';
         }
 
         // 関数を呼び出し、引数として購入金額と送料を渡す
         add_two_arguments(1200, 500);
        ?>

        関数の戻り値
        関数の内部で処理した結果は、比較演算子におけるTRUEまたはFALSEと
        同じように戻り値として返すことができます。戻り値を返さなければ
        関数だけで処理が終わりますが、戻り値を返すことでそれを他のコードに活用できます。

        戻り値を返すには、関数内でreturnを記述するだけです。
        なお、上記の例では戻り値の例として論理型のデータ（TRUEまたはFALSE）を挙げていますが、文字列型や整数型など、あらゆるデータ型を戻り値として返すことができます。


         例
         <?php
         // 戻り値を返す関数を定義する
        function is_purchased() {
            if (商品が購入されているならば) {
                return TRUE;
            } else {
                 return FALSE;
            }
        }

        // 戻り値を返す関数を条件式に使う（TRUEであれば処理が実行される）
            if (is_purchased()) {
                echo '商品は購入済みです。';
        }
        ?>

        具体的な例
        与えられた引数を2倍にし、その値をreturnで戻り値として返す関数を作成します。続いてその関数の戻り値をecho文で出力します。

        <?php
        // 与えられた引数$priceに送料を加算し、その値を出力する関数を定義する
        function calculate_total($price) {
            $total = $price + 500;

            echo $total . '円<br>';
        }

        // 関数を呼び出し、引数として購入金額を渡す
        calculate_total(1200);

        // 与えられた引数$priceと引数$shipping_feeを加算し、その値を出力する関数を定義する
        function add_two_arguments($price, $shipping_fee) {
            $total = $price + $shipping_fee;

            echo $total . '円<br>';
        }

        // 関数を呼び出し、引数として購入金額と送料を渡す
        add_two_arguments(1200, 500);
        ?>
    </p>
     <p>
         <?php
         // 与えられた引数$numを2倍にし、その値を戻り値として返す関数を定義する
         function double($num) {
             return $num * 2;
         }
 
         // 関数の戻り値を出力する        
         echo double(30);
         ?>
         型宣言のメリット
        型宣言のメリットを一言でいえば、「予期せぬ動作を防げること」です。
        例として、先ほど書いた引数$numを2倍にする関数を見てみましょう。
        この関数では型宣言をしていないので、引数$numには
        どのようなデータ型の値でも渡すことができます。

        「整数のみを使って計算したい」という場合、このままでは
        引数$numに浮動小数点型の値を渡したときに予期せぬ動作となってしまいます。
        そこで、「引数$numには必ず整数型のデータを渡してね」と型宣言をすれば、予期せぬ動作を防ぎ、「整数のみを使って計算したい」という期待に応えられるわけです。

        引数の型宣言
        <?php
        function double(int $num) {
            return $num * 2;
        }
        ?>

        intはinteger（整数）の略で、整数型を表すコードです。
        文字列型	    string	string＝文字列
        整数型	        int	    int＝整数を表すintegerの略
        浮動小数点型	float	float＝浮くもの。浮動小数点型のこと
        論理型	        bool	bool＝論理型を表すbooleanの別名

         <?php
         // 引数の型宣言を行い、引数を整数型に限定する
         function type_hinting_argument(int $num) {
             return $num * 2;
         }
 
         // 型宣言と異なるデータ型の引数を渡す（引数が強制的に整数型に変換される）       
         echo type_hinting_argument(1.618);
         ?>

         型宣言と異なるデータ型の場合にエラーを発生させてみよう

         「型宣言と異なるデータ型の引数を渡してしまったときに、エラーで知らせてほしい」という場面もあります。

         その場合、PHPファイルの先頭にdeclare(strict_types=1);というコードを記述すればOKです。

         なお、declare(strict_types=1);はPHPによる暗黙のデータ型変換を禁止して、引数や戻り値のデータ型を厳格にチェックしたいときに使うコードです。
          <?php
            // 型宣言と異なるデータ型の場合にエラーを発生させる
            declare(strict_types=1);
            ?>
        <!DOCTYPE html>
        <html lang="ja">

        <!--======== 中略 ========-->

        <p>
            <?php
            // 引数の型宣言を行い、引数を整数型に限定する
            function type_hinting_argument(int $num) {
                return $num * 2;
            } 
            // 型宣言と異なるデータ型の引数を渡す（PHPファイルの先頭にdeclare(strict_types=1);を記述しているのでエラーが発生する）       
            echo type_hinting_argument(1.618);
            ?>
        </p>
    </body>

    </html>

    「関数type_hinting_argument()の第1引数$numは整数型じゃなきゃダメだけど、浮動小数点型が渡されているよ」といった内容のエラーが記載されています。

    戻り値の型宣言
    引数以外には、関数の戻り値に対して型宣言を行うこともできます。戻り値の型宣言を行うには以下のように、関数の丸括弧()の後にコロン:とデータ型を記述すればOKです。
    <?php
    function double($num): int {
        return $num * 2;
    }   
    ?>


    具体的な例
PHPファイルの先頭にdeclare(strict_types=1);を記述しているため、型宣言と異なるデータ型の戻り値を返したことによってエラーが発生しています。
「関数type_hinting_return_value()の戻り値は整数型じゃなきゃダメだけど、浮動小数点型が返ってきたよ」といった内容のエラーが記載されています。
<p>
        <?php
        // 引数の型宣言を行い、引数を整数型に限定する
        function type_hinting_argument(int $num) {
            return $num * 2;
        }

        // 型宣言と同じデータ型の引数を渡す
        echo type_hinting_argument(1);
        ?>
    </p>
     <p>
         <?php
         // 戻り値の型宣言を行い、戻り値を整数型に限定する
         function type_hinting_return_value($num): int {
             return $num * 2;
         }
 
         // 型宣言と異なるデータ型の戻り値を返す（PHPファイルの先頭にdeclare(strict_types=1);を記述しているのでエラーが発生する）       
         echo type_hinting_return_value(1.618);
         ?>
     </p>
</body>

</html>

 スコープ
 スコープとは、変数を使える範囲（有効範囲） のことです。言い換えれば、変数の値を取得したり、変更したりできる範囲のことです。

 PHPのスコープは、「関数の中か外か」でローカルスコープとグローバルスコープの2つに分かれます。


 ローカルスコープ
 ローカルスコープとは、波括弧{}で囲まれた関数の中の有効範囲のことです。

 このローカルスコープで定義された変数のことを、ローカル変数といいます。ローカル変数はローカルスコープの範囲内、つまりその関数の中でしか使えません。

 簡単にいえば、「関数の中で定義した変数はその関数の中でしか使えないよ」ということです。


ローカルスコープの範囲内でローカル変数を使ってみよう（正しい使い方）

<!DOCTYPE html>
 <html lang="ja">
 
 <head>
     <meta charset="UTF-8">
     <title>PHP基礎編</title>
 </head>
 
 <body>
     <p>
         <?php
         function show_user_name() {
             // ローカル変数を定義する
             $user_name = '侍太郎';
 
             // ローカルスコープの範囲内でローカル変数を使う
             echo $user_name . '<br>';
         }
 
         show_user_name();
         ?>
     </p>
 </body>
 
 </html>

 ローカルスコープの範囲外でローカル変数を使ってみよう（間違った使い方）

 <?php
        function show_user_name() {
            // ローカル変数を定義する
            $user_name = '侍太郎';

            // ローカルスコープの範囲内でローカル変数を使う
            echo $user_name . '<br>';
        }

        show_user_name();

         // ローカルスコープの範囲外でローカル変数を使う（エラーが発生する）
         echo $user_name;
?>

 グローバルスコープ

 グローバルスコープとは、関数の外の有効範囲のことです。

 グローバルスコープで定義された変数のことを、グローバル変数といいます。グローバル変数はグローバルスコープの範囲内、つまり関数の外でしか使えません。
言い換えれば、グローバル変数は関数の中で使えないということです。

グローバルスコープの範囲内でグローバル変数を使ってみよう（正しい使い方）

<?php
         // グローバル変数を定義する
         $user_name = '侍花子';

        function show_user_name() {
            // ローカル変数を定義する
            $user_name = '侍太郎';

            // ローカルスコープの範囲内でローカル変数を使う
            echo $user_name . '<br>';
        }

        show_user_name();

         // グローバルスコープの範囲内でグローバル変数を使う
         echo $user_name;
        ?>

グローバルスコープの範囲外でグローバル変数を使ってみよう（間違った使い方）

グローバルスコープの範囲外でグローバル変数を使ってみます。


<?php
        // グローバル変数を定義する
        $user_name = '侍花子';

        function show_user_name() {
            // ローカル変数を定義する
            // $user_name = '侍太郎';
            
            // グローバルスコープの範囲外でグローバル変数を使う（エラーが発生する）
            echo $user_name . '<br>';
        }
        show_user_name();

        // グローバルスコープの範囲内でグローバル変数を使う
        echo $user_name;
        ?>


    クラス

例えばAmazonのようなショッピングサイトにおいて大量の商品データを作るとき、ゼロから個別の商品データを作るのは極めて大変です。

そこで使うのがクラスです。クラスを使えば、類似するデータを大量に作れるようになる

PHPにおけるオブジェクトとは、「独自の変数や関数をひとまとめにしたもの」のことです。

例えばAmazonのようなショッピングサイトで販売されている「シャンプー」という商品も、1つのオブジェクトと考えることができます。

クラスとは
クラスとは一言でいえば、モノ（オブジェクト）の設計図です
一度クラス（設計図）を作ってしまえば、同じ特徴を持った別個のオブジェクト（モノ）を大量生産できるようになるため、とても便利です。

クラスをもとに作られたオブジェクトのことを、特別にインスタンスと呼びます。
クラスをもとにインスタンスを作ることをインスタンス化といいます
インスタンスは「実体」という意味

クラスの作り方

class クラス名 {
    クラスの特徴
}

例えば商品（Product）というクラスであれば、以下のように記述します。
なお、クラス名は慣習的に先頭を大文字にします

<?php
class Product {
    クラスの特徴
}
?>

インスタンス化する方法

クラスをもとにオブジェクトを作る、
つまりインスタンス化するには以下のようにnew クラス名()と記述します。
newはインスタンス化するときのお作法です。


<?php
// クラスを定義する
class Product {
    クラスの特徴
}

// インスタンス化する
$shampoo = new Product();
?>

プロパティ

オブジェクトが持つデータ（変数）のこと
例えば「シャンプー」というオブジェクトであれば
「商品名」「価格」「カテゴリー」「在庫数」などがプロパティに該当します。

プロパティの書き方

<?php
class Product {
    // プロパティを定義する
    public $name;
}
?>
上記の例では、$nameがプロパティに該当します。

プロパティの前に記述しているpublicはアクセス権（どこからアクセスできるか）を
表すコードです。
上記のようにpublicと記述すれば、そのプロパティはどこからでも
（クラス内からでもクラス外からでも）アクセスできるようになります。

一方で、privateと記述すると同じクラスの中からしかアクセスできなくなります（クラス外からアクセスできなくなる）
publicよりも制限は多くなりますが、その分安全性が高まるため、
基本はprivateを使って必要に応じてアクセス権を広げるとよいでしょう。

プロパティへのアクセス方法
プロパティにアクセスし、値を代入したり取得したりするには、
以下のようにアロー演算子->を使います（arrow＝矢印）。


<?php
class Product {
    public $name;
}

$shampoo = new Product();

// プロパティにアクセスし、値を代入する
$shampoo->name = 'シャンプー';

// プロパティにアクセスし、値を出力する
echo $shampoo->name;
?>


プロパティを使ってみよう

<!DOCTYPE html>
 <html lang="ja">
 
 <head>
     <meta charset="UTF-8">
     <title>PHP基礎編</title>
 </head>
 
 <body>
     <p>
         <?php
         // クラスを定義する
         class Product {
             // プロパティを定義する
             public $name;
         }
 
         // インスタンス化する
         $shampoo = new Product();
 
         // プロパティにアクセスし、値を代入する
         $shampoo->name = 'シャンプー';
 
         // プロパティにアクセスし、値を出力する
         echo $shampoo->name;
         ?>
     </p>
 </body>
 
 </html>

  メソッド
  オブジェクトが持つ関数のことです。例えば「シャンプー」というオブジェクトであれば
  「在庫数を更新する関数」などがメソッドに該当します。


メソッドの書き方


<?php
class Product {
    private $name;

    // メソッドを定義する
    public function set_name(string $name) {
        $this->name = $name;
    }
}
?>

上記のコードでは、privateで定義しているプロパティ$nameにクラス外からアクセスすることはできません。
しかし、同じクラス内であればアクセスできるので、
同じクラス内のメソッドset_name()からはprivateで定義している
プロパティ$nameにアクセスできます（$this->name = $nameの部分）。
そして、publicで定義しているメソッドset_name()にはクラス外からアクセスできます。
クラス外から例えばset_name('シャンプー')のようにメソッドを呼び出すことで、
直接プロパティ$nameにはアクセスできなくても間接的に値を代入することができます。
メソッド内に記述している$thisはそのインスタンス自身を意味します。
プロパティにアクセスするには
インスタンス名->プロパティ名（例：$shampoo->name）と記述しますが
この「インスタンス名」の部分を$thisに置き換えているイメージです。


メソッドへのアクセス方法
メソッドにアクセスして実行するには、プロパティと同じようにアロー演算子->を使います。
<?php
class Product {
    private $name;

    public function set_name(string $name) {
        $this->name = $name;
    }
}

$shampoo = new Product();

// メソッドにアクセスして実行する
$shampoo->set_name('シャンプー');
?>
<?php
        // クラスを定義する
        class Product {
            // プロパティを定義する 
            private $name;
        // メソッドを定義する
             public function set_name(string $name) {
                 $this->name = $name;
             }
             public function show_name() {
                 echo $this->name . '<br>';
             }
        }

         // インスタンス化する
         $coffee = new Product();
 
         // メソッドにアクセスして実行する
         $coffee->set_name('コーヒー');
         $coffee->show_name();

        // インスタンス化する
        $shampoo = new Product();

        // プロパティにアクセスし、値を代入する
        $shampoo->name = 'シャンプー';

        // プロパティにアクセスし、値を出力する
        echo $shampoo->name;
        ?>

        コンストラクタ
クラスをもとにオブジェクトを作る（インスタンス化する）際に処理を行うメソッドのことです。
コンストラクタによって実行される最初の処理のことを、初期化といいます。
コンストラクタを使うことで、例えば「商品を作ると同時に出品する」といった最初の処理を設定できます。
コンストラクタを英語表記にするとconstructorで、「建設者」という意味があります

コンストラクタの書き方
<?php
class Product {
    // コンストラクタを定義する
    public function __construct() {
        初期化の内容
    }
}
?>

コンストラクタを使ってみよう
     <p>
         <?php
         // クラスを定義する
         class User {
             // プロパティを定義する                        
             private $name;
             private $age;
             private $gender;
 
             // コンストラクタを定義する
             public function __construct(string $name, int $age, string $gender) {
                 $this->name = $name;
                 $this->age = $age;
                 $this->gender = $gender;
             }
         }
 
         // インスタンス化する
         $user = new User('侍太郎', 36, '男性');
 
         // インスタンス$userの各プロパティの値を出力する
         print_r($user);
         ?>
     </p>

コンストラクタに引数を設定することで、インスタンス化するときに引数として渡した値をそれぞれのプロパティに代入できます。


定数

定数とは簡単にいえば、「あとから中身を入れ替えられない変数」のこと

変数：あとから中身を入れ替えられる（再代入できる）
定数：あとから中身を入れ替えられない（再代入できない）

定数は「予期せぬ再代入を防げる」という大きなメリットがあります。

「一律で値が決まっている『固定値』には定数を使う」

 定数の使い方
 
 constを記述します
 
<?php
const SHIPPING_FEE = 500;
?> 

まずは定数に値を代入し、その定数の中身を出力する簡単なコードを書いてみます。

    <p>
         <?php
         // 定数に値を代入する
         const SHIPPING_FEE = 500;
 
         // 定数の中身を出力する
         echo SHIPPING_FEE;
         ?>
     </p>



     前述のとおり、定数はあとから中身を入れ替えられません
      
        <?php
        // 定数に値を代入する
        const SHIPPING_FEE = 500;

        // 定数の中身を出力する
        echo SHIPPING_FEE;

         // 定数に値を再代入する（エラー）
         const SHIPPING_FEE = 800;
 
         // 定数の中身を出力する
         echo SHIPPING_FEE;
        ?>

        クラス内で定数を使ってみよう

        定数はクラス内に定義することもできます
        
        クラスに直接アクセスする場合は::（コロン2つ）を記述します。

         <?php
         // クラスを定義する
         class Product {
             // クラス内に定数を定義する
             public const TAX = 1.1;
         }
 
         // クラス内に定義された定数にアクセスする
         echo Product::TAX;
         ?>

         定数には配列（連想配列も含む）を入れることもできます

         <?php
         // 定数に配列を入れる
         const SEVEN_REGIONS = [
             '北海道地方',
             '東北地方',
             '関東地方',
             '中部地方',
             '近畿地方',
             '中国・四国地方',
             '九州地方'
         ];
 
         // 定数（配列）の中身を出力する
         print_r(SEVEN_REGIONS);
         ?>

         
         
         
         正規表現とは


アプリやサービスを開発していると、以下のように複雑な条件で文字列を検索したり、チェックしたりしたい場面が出てきます。

フォームに入力されたメールアドレスに「@（アットマーク）」が含まれているかどうかチェックする
フォームに入力されたメールアドレスが英数字と特定の記号（「@」や「.」など）のみで構成されているかどうかをチェックする
「070」「080」「090」のいずれかで始まっている電話番号を検索する
登録された電話番号が「-（ハイフン）」で区切られているかどうかチェックする

このような場面で便利なのが、正規表現

正規表現を使えば「アルファベットで始まり数字で終わる5文字の文字列」
「aから始まりnで終わる英単語」など、特定の文字列を指定しなくても
自由自在に文字列を検索したり、置換したりできるようになります

正規表現による処理は、ユーザーが入力した会員登録情報やログイン情報のチェックで
よく使われます。正規表現はPHPに限らず、他のプログラミング言語でも使う機会がある

例えば「あ」で始まって「り」で終わる文字列は「あり」「あたり」「あおもり」など
たくさん存在します。このような共通点を持つ複数の文字列を1つの文字列で
表現する方法のことを正規表現といいます。

\\xn--a-x7t.xn--*-uf4b\z\のような書き方が正規表現

正規表現が使える代表的なPHPの関数

preg_match()	    正規表現による検索を行い、最初に一致した文字列を取得する
preg_match_all()	正規表現による検索を行い、一致した文字列をすべて取得する
preg_replace()	    正規表現による検索を行い、一致した文字列を他の文字列に置換する
preg_grep()	        配列に対して正規表現による検索を行い、一致した要素を配列で返す

このようにPHPがもともと用意してくれている関数のことを、組み込み関数といいます
（内部関数やビルトイン関数と呼ばれることもあります）

作成した自分オリジナルの関数（say_good_morning()など）のことを、ユーザー定義関数といいます。



preg_match()：最初に一致した文字列を取得する

preg_match()は正規表現による検索を行い、最初に一致した文字列を取得する関数です。

preg_match(正規表現, 検索対象, 検索結果を代入する配列);

第3引数の「検索結果を代入する配列」はオプションなので渡さなくてもOKです。渡した場合、その配列に検索結果が代入されます。


部分一致

部分一致は「特定の文字列が含まれている状態」を一致とみなす検索方法

正規表現で部分一致を表すには、検索したい文字列を/（スラッシュ）で囲うだけでOKです。
例えば「@」が含まれているかどうかを検索するには/@/と記述します。
部分一致に限らず、正規表現は慣習的に/（スラッシュ）で囲うので覚えておきましょう。

 <h2>
         <?php
         // str＝「文字列」を意味するstringの略
         $str = 'Appleが5個あります。Orangeは1個しかありません。';
 
         echo '検索対象：' . $str;
         ?>
     </h2>
     <p>
         <?php
         echo '「Orange」が含まれているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/Orange/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

    
    
    
     前方一致

前方一致は「特定の文字列で始まっている状態」を一致とみなす検索方法です。

正規表現で前方一致を表すには、検索したい文字列の直前に^（ハット）をつければOKです。例えば「090」で始まっているかどうかを検索するには/^090/と記述します。

なお、「^（ハット）」キーは「0」の2つ右にあります。

 <p>
         <?php
         echo '「A」で始まっているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/^A/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

    
    
    
    後方一致

後方一致は「特定の文字列で終わっている状態」を一致とみなす検索方法です。

正規表現で後方一致を表すには、検索したい文字列の直後に$（ドル記号）をつければOKです。
例えば「。」で終わっているかどうかを検索するには/。$/と記述します。

 <p>
         <?php
         echo '「。」で終わっているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/。$/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     完全一致

     完全一致は「特定の文字列と完全に一致している状態」を一致とみなす検索方法です。

正規表現で完全一致を表すには、検索したい文字列を\Aと\zで囲めばOKです。
例えば「侍太郎」と完全に一致しているかどうかを検索するには/\A侍太郎\z/と記述します。


<p>
         <?php
         echo '「Appleが5個あります。Orangeは1個しかありません。」と完全に一致しているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/\AAppleが5個あります。Orangeは1個しかありません。\z/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     
     
「『Apple』または『Orange』」など、複数の文字列で検索したいケースも出てきます。

正規表現でそのような選択肢（または）を表すには、|（バーティカルバー）を記述すればOKです。
例えば「Apple」または「Orange」を


 <p>
         <?php
         echo '「Apple」または「Orange」が含まれているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/Apple|Orange/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
</p>

ブラウザを更新して実行結果を確認してみましょう。
検索対象には「Apple」または「Orange」という文字列が含まれているため
戻り値として1が返され、if文の条件が成り立つときの処理が実行されました。

一時的に変数$strの「Apple」と「Orange」の両方を削除して、結果が変わることも確認してみてください。


小文字のアルファベット
ここからはやや応用的な正規表現を学びます。先ほどまではAppleやOrangeなど
「特定の」文字列を正規表現で検索しました。一方で、正規表現を使えば
「小文字のアルファベットであれば何でもOK」というように
「任意の」1文字を検索することも可能です。

任意の1文字を正規表現で表すには角括弧[]で囲みます。
例えば「任意の小文字のアルファベット」を正規表現で表すには[a-z]と記述します。
なお、この-（ハイフン）は「aからzまで」という範囲を表しています。

 <?php
         echo '小文字のアルファベットが含まれているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/[a-z]/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
 ?>

 ブラウザを更新して実行結果を確認してみましょう。
 検索対象には「小文字のアルファベット」が含まれているため、戻り値として1が返され
 if文の条件が成り立つときの処理が実行されました。

 一時的に変数$strの「小文字のアルファベット」をすべて削除して
 結果が変わることも確認してみてください。


大文字のアルファベット

「任意の大文字のアルファベット」を正規表現で表すには[A-Z]と記述します。

 <?php
         echo '大文字のアルファベットが含まれているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/[A-Z]/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
?>

一時的に変数$strの「大文字のアルファベット」をすべて削除して、結果が変わることも確認してみてください。



数字

「任意の数字」を正規表現で表すには[0-9]と記述します。

 <?php
         echo '数字が含まれているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/[0-9]/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
?>



ブラウザを更新して実行結果を確認してみましょう。検索対象には「数字」が含まれているため、
戻り値として1が返されif文の条件が成り立つときの処理が実行されました。



英数字

先ほどの大文字、小文字のアルファベットと数字を組み合わせ、
[a-zA-Z0-9]と記述すれば「任意の英数字」を検索できます。

任意の1文字を表す角括弧[]の中では「または」を意味する
|（バーティカルバー）を記述する必要はありません。
例えば[abc]とそのまま続けて記述すれば、「aまたはbまたはcのうちいずれか1文字」という意味になります。

 <?php
         echo '英数字が含まれているかどうかを正規表現で検索します。<br>';
 
         if (preg_match('/[a-zA-Z0-9]/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
?>


検索結果を配列に代入してみよう

preg_match()関数を使って検索結果を配列に代入してみましょう。

preg_match()は正規表現による検索を行い、最初に一致した文字列を
取得する関数であることを学びました。また、オプションとして第3引数に
「検索結果を代入する配列」を渡せることも学びました。

第3引数に$resultsという名前の配列を渡し、検索結果を代入してみます。

<p>
         <?php
         echo '英数字が含まれているかどうかを正規表現で検索し、検索結果を配列に代入します。<br>';
 
         if (preg_match('/[a-zA-Z0-9]/', $str, $results)) {
             echo '>検索結果：';
             print_r($results);
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     preg_match()は最初に一致した文字列を取得する関数なので、
     今回は最初に一致した「A」のみが取得されました。
     一致した文字列をすべて取得したい場合は、preg_match_all()関数を使います。

     
     
     preg_match_all()：一致した文字列をすべて取得する

     preg_match_all(正規表現, 検索対象, 検索結果を代入する配列);

     preg_match()関数と同じように、第3引数の「検索結果を代入する配列」はオプションなので渡さなくてもOKです。
     渡した場合、その配列に検索結果が代入されます。
　　では実際に、preg_match_all()関数を使ってより応用的な正規表現の使い方を学びましょう。



検索結果を配列に代入してみよう


  <h2>
         <?php
         $str = 'Appleが5個あります。Orangeは1個しかありません。';
 
         echo '検索対象：' . $str;
         ?>
     </h2>
     <p>
         <?php
         echo '英数字が含まれているかどうかを正規表現で検索し、検索結果を配列に代入します。<br>';
 
         if (preg_match_all('/[a-zA-Z0-9]/', $str, $results)) {
             echo '>検索結果：';
             print_r($results);
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>
 配列の中身がArray ( [0] => Array……となっていますが、これは配列の中にさらに別の配列が入っていることを表します。

実は配列は、配列 = [配列1, 配列2, 配列3……]のように、別の配列を入れ子にすることもできます。このような配列を多次元配列と呼ぶ。



1回以上の繰り返し
先ほど正規表現として記述した[a-zA-Z0-9]は「任意の1文字の英数字」を表すので
1文字ずつバラバラに取得されました。

そこで今回は「1回以上の繰り返し（1文字以上）」を表す+（プラス）を使って
「Apple、5、Orange、1」のようにまとまった文字列として取得してみましょう。

 <p>
         <?php
         echo '1回以上繰り返されている（1文字以上の）英数字が含まれているかどうかを正規表現で検索し、検索結果を配列に代入します。<br>';
 
         if (preg_match_all('/[a-zA-Z0-9]+/', $str, $results)) {
             echo '>検索結果：';
             print_r($results);
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     
     
     改行以外のすべての文字

正規表現では、「改行以外のすべての1文字」を.（ドット）で表すことができます。
例えば先ほどの「1回以上の繰り返し」を表す+（プラス）と組み合わせて.+と記述すると
「改行以外の1文字以上の文字」を検索できます。

なお、改行文字とは\nや\rのことです。


<p>
         <?php
         echo '改行以外の1回以上繰り返されている（1文字以上の）文字が含まれているかどうかを正規表現で検索し、検索結果を配列に代入します。<br>';
 
         if (preg_match_all('/.+/', $str, $results)) {
             echo '>検索結果：';
             print_r($results);
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
 </p>


0回以上の繰り返し

先ほどは「1回以上の繰り返し」を表す+（プラス）を使いましたが
*（アスタリスク）をつければ「0回以上の繰り返し」を表すことができます。

例えば「あ」で始まって「り」で終わる文字列などを検索するときに便利です。

「あ」で始まって「り」で終わる文字列は「あ○り」「あ○○り」「あ○○○り」のように、
「あ」と「り」の間に何文字あってもOKです。そしてもちろん、
「あり」のように「あ」と「り」の間が0文字でもよいわけです。

 <h2>
         <?php
         $str = 'あり';
 
         echo '検索対象：' . $str;
         ?>
     </h2>
     <p>
         <?php
         echo '「あ」で始まって「り」で終わる文字列と完全に一致しているかどうかを正規表現で検索します。<br>';
 
         if (preg_match_all('/\Aあ.*り\z/', $str)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     
     
     メールアドレスのフォーマットチェックに挑戦してみよう

     例として、以下のようなメールアドレスのフォーマットに
     従っているかどうかを正規表現でチェックします。

     使える文字は英数字または「.（ドット）」のみ
「○○○@□□□」のように、間に「@（アットマーク）」が入る
ユーザー名（@の左側）とドメイン名（@の右側）はそれぞれ1文字以上

 <h2>
         <?php
         $email = 'taro.samurai55@example.com';
 
         echo '検索対象：' . $email;
         ?>
     </h2>
     <p>
         <?php
         echo 'メールアドレスのフォーマットと完全に一致しているかどうかを正規表現で検索します。<br>';
 
         if (preg_match_all('/\A[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\z/', $email)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     
     
     携帯電話番号のフォーマットチェック

     携帯電話番号のフォーマットに従っているかどうかを正規表現でチェックします。

     先頭が「070」「080」「090」のいずれかで始まる
    「○○○-●●●●-■■■■」のように「-（ハイフン）」で区切る
    3桁、4桁、4桁の計11桁にする
    今回新しく桁数（文字数）の指定が登場します。

    「n回の繰り返し」のように、文字数を正規表現で指定するには波括弧{}を使って
    {n}と記述します。例えば「4桁の数字」を正規表現で表すには[0-9]{4}と記述すればOK

    [0-9][0-9][0-9][0-9]と記述しても「4桁の数字」を表すことはできますが
    [0-9]{4}と記述したほうがコードがスッキリして可読性も上がるので
    こちらの書き方に慣れましょう。

     <h2>
         <?php
         $mobile = '090-0000-0000';
 
         echo '検索対象：' . $mobile;
         ?>
     </h2>
     <p>
         <?php
         echo '携帯電話番号のフォーマットと完全に一致しているかどうかを正規表現で検索します。<br>';
 
         if (preg_match_all('/\A0[7-9]0-[0-9]{4}-[0-9]{4}\z/', $mobile)) {
             echo '>正規表現に一致しました。';
         } else {
             echo '>正規表現に一致しませんでした。';
         }
         ?>
     </p>

     
     
     preg_replace()：一致した文字列を他の文字列に置換する

     preg_match()やpreg_match_all()は、一致した文字列を取得する関数でした。

一方で、preg_replace()は正規表現による検索を行い
一致した文字列を他の文字列に置換する関数です。例えば、「『-（ハイフン）』つきで
登録された電話番号を数字のみの電話番号に一括で置換したい」という場面でとても便利です。



preg_replace()関数の引数には主に以下の値を渡します。

preg_replace(正規表現, 置換後の文字列, 検索対象);


正規表現のグループ化

preg_replace()関数を使い、携帯電話番号を正規表現で検索し


ただしここで1つ問題となるのが、「第2引数に渡す『置換後の文字列』をどう表現するか」という点です。

例えば'090-0000-0000'のように「特定の電話番号」であれば
第2引数に直接'0900000000'を渡せばOKです。
しかし、先ほど16.3節の最後で記述した'/\A0[7-9]0-[0-9]{4}-[0-9]{4}\z/'のように
正規表現で表した「任意の電話番号」の場合はどうすればよいでしょうか。

なお、正規表現の-（ハイフン）を削除して、第2引数に'/\A0[7-9]0[0-9]{4}[0-9]{4}\z/'を
渡しても正しく動作しません。

このように正規表現で表した「任意の電話番号」を正しく置換するには、
丸括弧()でグループ化すればOKです。

例えば(○○○)-(●●●●)-(■■■■)のようにグループ化すれば、
1つ目のグループ（○○○）を$1、2つ目のグループ（●●●●）を$2、
3つ目のグループ（■■■■）を$3で表すことができます。
つまり、第2引数に'$1$2$3'を渡せば、「-（ハイフン）」を削除した
電話番号に置換できるということです。

なお、preg_replace()関数は第3引数の検索対象に配列（連想配列も含む）を渡せるので、
今回は連想配列を渡します。

<h2>
         <?php
         $personal_data = [
             'name' => '侍太郎',
             'address' => '侍町7-77',
             'mobile' => '090-0000-0000'
         ];
 
         echo '検索対象：';
         print_r($personal_data);
         ?>
     </h2>
     <p>
         <?php
         echo '携帯電話番号を検索し、一致すれば-（ハイフン）を削除したものに置換します。<br>';
 
         $no_hyphen = preg_replace('/\A(0[7-9]0)-([0-9]{4})-([0-9]{4})\z/', '$1$2$3', $personal_data);
 
         echo '>置換結果：';
         print_r($no_hyphen);
         ?>
     </p>

     preg_replace()関数は戻り値として置換後の文字列（第3引数に配列を渡した場合は配列）を返すので、
     一度$no_hyphenという変数に代入しています。

     
     preg_grep()：一致した要素を配列で返す

    preg_grep()は配列に対して正規表現による検索を行い、一致した要素を配列で返す関数です。

    preg_grep(正規表現, 検索対象);


preg_grep()関数を使ってみましょう。今回はさまざまなメールアドレスが入った配列を用意し
preg_grep()関数を使ってフォーマットに一致するメールアドレスのみを配列で返してみます。

 <h2>
         <?php
         $emails = [
             'taro.samurai55@example.com',
             'taro.samurai55@@example.com',
             '875-samurai.example',
             '875.Samurai@example.com'
         ];
 
         echo '検索対象：';
         print_r($emails);
         ?>
     </h2>
     <p>
         <?php
         echo 'メールアドレスのフォーマットと完全に一致している要素のみを配列で返します。<br>';
 
         $right_emails = preg_grep('/\A[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\z/', $emails);
 
         echo '>返却結果：';
         print_r($right_emails);
         ?>
     </p>



PHPで日付や時刻を取得する方法を知ること
DateTimeクラスを使って日時の差を比較したり、計算したりする方法を知ること

プログラミングにおいて日付や時刻を取得したり、計算したりする機会は多いです。
例えば学習記録アプリやスケジュール管理アプリの場合
日時の操作がメインになるといっても過言ではありません。

いざ日時を扱う機会が訪れたときに戸惑わないように、本章で苦手意識をなくしておきましょう。

PHPで日時を取得する主な方法は、以下の2つです。

date()関数
DateTimeクラス
なお、本章では日時の表示形式（「2015年3月19日」「2015-03-19」など）を
指定するための特殊な文字（「Y」「m」「%a」など）がたくさん登場しますが
これらを暗記する必要はありません。使い方を忘れたときや、実際に使うときに本章に戻って復習すればOKです。



date()関数


date()は、特定のフォーマットで日時の文字列を返す関数です。

引数には以下の値を渡します。


date(日時のフォーマット, UNIXタイムスタンプ);


「日時のフォーマット」には文字列型の値（例：'Y年n月j日'）、
第2引数の「UNIXタイムスタンプ」には整数型の値（例：1652662122）を渡します。
なお、第2引数はオプションなので省略可能です。
省略した場合は現在の日時が戻り値として返されます。

ここで、日時のフォーマットとUNIXタイムスタンプについて学びましょう。



日時のフォーマット
日時のフォーマットとは、例えば「2015年3月19日」「2015-03-19」
「2015/03/19 12:30:00」など、さまざまな表示形式のことです。

日時のフォーマットを指定するには「Y」や「n」などの特殊なフォーマット文字を使います。
代表例は以下のとおりです。ざっと見てイメージをつかんでおきましょう。

日時のフォーマット文字	意味	例
Y	年（4桁表記）	2015、2022など
y	年（2桁表記）	15、22など
m	月（先頭に0をつける）	01～12
n	月（先頭に0をつけない）	1～12
d	日（先頭に0をつける）	01～31
j	日（先頭に0をつけない）	1～31
H	24時間単位の時間（先頭に0をつける）	00～23
G	24時間単位の時間（先頭に0をつけない）	0～23
h	12時間単位の時間（先頭に0をつける）	01～12
g	12時間単位の時間（先頭に0をつけない）	1～12
i	分（先頭に0をつける）	00～59
s	秒（先頭に0をつける）	00～59
例えば「2015年3月19日」のように表示したいときは、'Y年n月j日'を指定すればOKです。


例

 <p>
         <?php
         // 使用するデフォルトのタイムゾーンを指定する
         date_default_timezone_set('Asia/Tokyo');
 
         // 現在の日時を指定したフォーマットで出力する
         echo date('Y年n月j日H時i分s秒') . '<br>';
         ?>
     </p>

     UNIXタイムスタンプ
UNIXタイムスタンプとは、例えば「1426690800」「1652662122」など
1970年1月1日0時0分0秒からの経過秒数のことです。
date()関数を使って「現在以外の日時」を取得したいときは
このUNIXタイムスタンプを第2引数として渡す必要があります。

UNIXタイムスタンプを取得するにはstrtotime()関数を使えば簡単です。
strtotime()は、日時をUNIXタイムスタンプ（整数）に変換する関数です。


引数には以下の値を渡します。

strtotime(日時, 基準となるUNIXタイムスタンプ);

第1引数の「日時」には文字列型の値（例：'now'、'+1 day'など）、
第2引数の「基準となるUNIXタイムスタンプ」には整数型の値（例：1652662122）を渡します。
第2引数はオプションなので省略可能です。
省略した場合は現在を基準とした
第1引数の「日時」のUNIXタイムスタンプが戻り値として返されます。

なお、第1引数の「日時」には'19 March 2015'（2015年3月19日）のような絶対日時だけでなく、
'+1 day'（1日後）のような相対日時も指定することができます。
例えばstrtotime('+1 day', 2015年3月19日のUNIXタイムスタンプ)と記述した場合
「2015年3月19日の1日後」という相対日時のUNIXタイムスタンプを取得できます。


strtotime()関数における日時の主な指定方法は以下のとおりです
（実際に使うときにその都度調べればOKなので、覚える必要はありません）。

strtotime()関数における日時の指定方法	
now	                    現在の日時
today	                今日の日付
yesterday	            前日
tomorrow	            翌日
19 March 2015	        指定日付
2015-03-19 12:15:30	    指定日時
+n（-n） seconds	    n秒後（前）
+n（-n） min	        n分後（前）
+n（-n） hours	        n時間後（前）
+n（-n） day	        n日後（前）
+n（-n） week	        n週後（前）
+n（-n） month	        nか月後（前）
+n（-n） year	        n年後（前）
next Monday	            翌週の指定曜日
last Monday	            前週の指定曜日


  <p>
        <?php
        // 使用するデフォルトのタイムゾーンを指定する
        date_default_timezone_set('Asia/Tokyo');

        // 現在の日時を指定したフォーマットで出力する
        echo date('Y年n月j日H時i分s秒') . '<br>';

         // 現在を基準として1週間後の日時のUNIXタイムスタンプを出力する
         echo strtotime('+1 week') . '<br>';
        ?>

        今回はstrtotime()関数に第1引数のみを渡しているので、
        現在を基準として1週間後の日時のUNIXタイムスタンプが表示されます
        （コードを実行した日時によって出力される値は異なります）。

        date()関数とstrtotime()関数を組み合わせて使ってみよう

        date()関数の第2引数としてstrtotime()関数を渡し、現在以外の日時を取得してみましょう。

        <p>
        <?php
        // 使用するデフォルトのタイムゾーンを指定する
        date_default_timezone_set('Asia/Tokyo');

        // 現在の日時を指定したフォーマットで出力する
        echo date('Y年n月j日H時i分s秒') . '<br>';

        // 現在を基準として1週間後の日時のUNIXタイムスタンプを出力する
        echo strtotime('+1 week') . '<br>';

         // 現在を基準として3年前の日時を指定したフォーマットで出力する
         echo date('Y/m/d H:i:s', strtotime('-3 year'));
        ?>
    </p>

   
   
    DateTimeクラス

    PHPで日時を取得するもう1つの方法が、DateTimeクラスです。
    DateTimeはPHP側がもともと用意してくれているクラスで
    日時の取得・比較・計算といった便利なメソッドが使えます。

DateTimeクラスを使うには、まず以下のようにインスタンス化します。
インスタンス化するときに引数を渡さなければ「現在の日時」という
情報を持つインスタンスが作成され、引数を渡して日付や日時を指定すれば
その情報を持つインスタンスが作成されます。

<?php
// 現在の日時のインスタンスを作成する
$now = new DateTime();

// 指定した日付のインスタンスを作成する
$date = new DateTime('2015-03-19');

// 指定した日時のインスタンスを作成する
$date_time = new DateTime('2015-03-19 12:15:30');
?>


インスタンスが持つ日時の情報を特定のフォーマットで取得するには
以下のようにformat()メソッドを使います。

<?php
// 指定した日時のインスタンスを作成する
$date_time = new DateTime('2015-03-19 12:15:30');

// インスタンス$date_timeの日時を特定のフォーマットで出力する
echo $date_time->format('Y年n月j日H時i分s秒');
?>



DateTimeクラスを使ってみよう

DateTimeクラスを使ってみましょう。

date-time.phpを以下のように編集してください。
今回はインスタンス化するときに引数を渡して日時を指定し
その日時を特定のフォーマットで出力してみます。

 <p>
         <?php
         // 指定した日時のインスタンスを作成する
         $date_time = new DateTime('2015-03-19 12:15:30');
 
         // インスタンス$date_timeの日時を特定のフォーマットで出力する
         echo $date_time->format('Y年n月j日H時i分s秒') . '<br>';
         ?>
     </p>



     2つの日時の差を比較してみよう

     DateTimeクラスが持つdiff()メソッドを使えば、2つの日時の差を比較することもできます。

diff()メソッドの使い方は以下のとおりです。
diff()メソッドの引数には日時の差を比較したいインスタンスを渡します。

<?php
$now = new DateTime();
$date_time = new DateTime('2015-03-19 12:15:30');

// diff()メソッドで2つのインスタンスの日時の差を取得し、変数$intervalに代入する（interval＝間隔）
$interval = $now->diff($date_time);

// 取得した日時の差を特定のフォーマットで出力する
echo $interval->format('%y年と%m月と%d日の差があります。総日数は%a日です。');
?>

なお、日時そのものではなく「日時の差（間隔）」のフォーマットを指定するときは
以下のように%をつけたフォーマット文字を使う必要があります
（実際に使うときにその都度調べればOKなので、覚える必要はありません）。

間隔のフォーマット文字		
%Y	年（先頭に0をつける）	    03、05など
%y	年（先頭に0をつけない）	    3、5など
%M	月（先頭に0をつける）	    01～12
%m	月（先頭に0をつけない）	    1～12
%D	日（先頭に0をつける）	    01～31
%d	日（先頭に0をつけない）	    1～31
%H	時間（先頭に0をつける）	    01～23
%h	時間（先頭に0をつけない）	1～23
%I	分（先頭に0をつける）	    01～59
%i	分（先頭に0をつけない）	    1～59
%S	秒（先頭に0をつける）	    01～59
%s	秒（先頭に0をつけない）	    1～59
%a	総日数	                    365など

<?php
        // 指定した日時のインスタンスを作成する
        $date_time = new DateTime('2015-03-19 12:15:30');

        // インスタンス$date_timeの日時を特定のフォーマットで出力する
        echo $date_time->format('Y年n月j日H時i分s秒') . '<br>';

         // 現在の日時のインスタンスを作成する
         $now = new DateTime();
 
         // diff()メソッドで2つのインスタンスの日時の差を取得し、変数$intervalに代入する（interval＝間隔）
         $interval = $now->diff($date_time);
 
         // 取得した日時の差を特定のフォーマットで出力する
         echo $interval->format('%y年と%m月と%d日の差があります。総日数は%a日です。') . '<br>';
        ?>

       
       
        日時を加算・減算してみよう

        最後に、DateTimeクラスが持つmodify()メソッドを使って日時を加算・減算してみましょう（modify＝変更する）。

 <?php
// 加算・減算してもインスタンス$nowの日時が変わらないように、DateTimeImmutableクラスを使って作成する
$now = new DateTimeImmutable();

// 現在の日時に1年を加算し、変数$addに代入する
$add = $now->modify('+1 year');

// 現在の日時から3日を減算し、変数$subに代入する（sub＝「減算」を意味するsubtractionの略）
$sub = $now->modify('-3 day');

// 加算・減算した日時を特定のフォーマットで出力する
echo $add->format('現在から1年後はY年n月j日H時i分s秒です。');
echo $sub->format('現在から3日前はY年n月j日H時i分s秒です。');
?>

上記の例ではDateTimeクラスの仲間であるDateTimeImmutableクラスを使っています（Immutable＝不変）。


仮にインスタンス$nowをDateTimeクラスから作成した場合、$add = $now->modify('+1 year');でmodify()メソッドを使った時点で$nowの日時が変更されてしまいます。よって、$sub = $now->modify('-3 day');が「現在から3日前」ではなく、「現在から1年後の3日前」になってしまいます。

そのため、今回はDateTimeクラスの仲間であるDateTimeImmutableクラスを使い、インスタンス$nowの日時が変更されないようにしました。

DateTimeクラス＝作成後もインスタンスの状態を変更できる
DateTimeImmutableクラス＝作成後はインスタンスの状態を変更できない
日時の加算・減算方法は以下のとおりです。

modify()メソッドにおける日時の加算・減算方法
+n（-n） seconds	n秒後（前）
+n（-n） min	    n分後（前）
+n（-n） hours	    n時間後（前）
+n（-n） day	    n日後（前）
+n（-n） week	    n週後（前）
+n（-n） month	    nか月後（前）
+n（-n） year	    n年後（前）

  <?php
        // 指定した日時のインスタンスを作成する
        $date_time = new DateTime('2015-03-19 12:15:30');

        // インスタンス$date_timeの日時を特定のフォーマットで出力する
        echo $date_time->format('Y年n月j日H時i分s秒') . '<br>';

        // 現在の日時のインスタンスを作成する
        $now = new DateTime();

        // diff()メソッドで2つのインスタンスの日時の差を取得し、変数$intervalに代入する（interval＝間隔）
        $interval = $now->diff($date_time);

        // 取得した日時の差を特定のフォーマットで出力する
        echo $interval->format('%y年と%m月と%d日の差があります。総日数は%a日です。') . '<br>';

         // 加算・減算してもインスタンス$nowの日時が変わらないように、DateTimeImmutableクラスを使って作成する
         $now = new DateTimeImmutable();
 
         // 現在の日時に1年を加算し、変数$addに代入する
         $add = $now->modify('+1 year');
 
         // 現在の日時から3日を減算し、変数$subに代入する（sub＝「減算」を意味するsubtractionの略）
         $sub = $now->modify('-3 day');
 
         // 加算・減算した日時を特定のフォーマットで出力する
         echo $add->format('現在から1年後はY年n月j日H時i分s秒です。') . '<br>';
         echo $sub->format('現在から3日前はY年n月j日H時i分s秒です。');
        ?>

        
        
        補足：date()関数とDateTimeクラスの使い分け

        date()関数とDateTimeクラスは、日時を取得するだけであれば基本的にできることは一緒です。よって、自分が使いやすい（コードを書きやすい）ほうを選べばOKです。

        ただし、日時の取得だけでなく差を比較したり計算したりしたい場合は、便利なメソッドが用意されているDateTimeクラス（またはDateTimeImmutableクラス）を使うとよいでしょう。

        
        乱数とは

        乱数とは一言でいえば、「ランダムな数」のことです。
        サイコロの出目のように何が出るかわからないため
        すごろくやおみくじのようなゲームはもちろんのこと
        SMS認証やテスト用のダミーデータ生成などさまざまな場面で使われます。

        SMS認証＝携帯電話のショートメッセージサービスを利用して
        4～6桁程度の確認コードを送信し、そのパスワードを入力させる認証方法のこと

        ダミーデータ＝アプリやサービスを開発していると動作を確認するために
        実際のデータ（ユーザーの年齢や商品の価格など）が
        必要になることがあるが、その際に作成する実在しない見せかけのデータのこと



        PHPで乱数を扱う関数としては、mt_rand()関数とarray_rand()関数が代表的です。
        なお、randは「ランダム」を意味するrandomの略です。

        mt_rand()：乱数を生成する
        array_rand()：配列のキーをランダムに取得する



        mt_rand()：乱数を生成する

        mt_rand()は、乱数を生成する関数です。

        引数には以下の値を渡します。
        
        mt_rand(最小値, 最大値);

条件分岐や繰り返し処理でも使ったので覚えている方もいると思いますが、
例えばmt_rand(0, 4)と記述すれば、「0～4までのランダムな整数」を生成できます。   


<p>
         <?php
         // 変数$diceにサイコロの出目（1～6までのランダムな整数）を代入する
         $dice = mt_rand(1, 6);
 
         // サイコロの出目を出力する
         echo "{$dice}の目が出ました。";
         ?>
     </p>

     
     

array_rand()：配列のキーをランダムに取得する

array_rand()は、配列（連想配列も含む）のキーをランダムに取得する関数です（配列の場合はキー＝インデックス）。

例えば以下のような配列があった場合に、array_rand()関数で取得した配列のキーを使えば、いずれか1つの要素を簡単に取得できます。

$omikuji = ['大吉', '中吉', '小吉', '吉', '末吉', '凶', '大凶'];

array_rand()関数の引数には以下の値を渡します。
array_rand(配列、取得するキーの数);

第2引数の「取得するキーの数」はオプションなので省略できます。省略した場合は、取得するキーの数が1つになります。


<p>
         <?php
         // おみくじの結果を入れた配列$omikujiを作成する
         $omikuji = ['大吉', '中吉', '小吉', '吉', '末吉', '凶', '大凶'];
 
         // 変数$keyにランダムな配列のキー（インデックス）を代入する
         $key = array_rand($omikuji);
 
         // 取得した配列のキー（インデックス）を使ってその値を取得し、変数$resultに代入する
         $result = $omikuji[$key];
 
         // おみくじの結果を出力する
         echo "おみくじの結果は{$result}です。";
         ?>
     </p>

フォームに入力された値をPHPで取得する方法を知ること
お問い合わせフォームと入力内容の確認画面を作成すること

PHPの強みの1つに、「フォームに入力された値を簡単に取得できる」という点が挙げられます。

フォームに入力された値を取得することで、フォームを送信する前に
ユーザーに入力内容の確認画面を表示するなど、
webサイトやWebサービスでよく使われている機能を簡単に実装できるようになります。

